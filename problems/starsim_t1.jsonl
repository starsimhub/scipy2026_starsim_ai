{"problem_id": "starsim_t1", "sub_step_id": "starsim_t1.1", "description": "Create and run a basic SIR (susceptible-infectious-recovered) simulation using Starsim. The simulation should use a random contact network and return the completed simulation object.", "function_header": "def create_sir_sim(n_agents: int = 10_000, n_contacts: int = 10, init_prev: float = 0.01, beta: float = 0.05) -> ss.Sim:", "docstring": "Create and run a basic SIR disease simulation using Starsim.\n\nArgs:\n    n_agents: Number of agents to simulate.\n    n_contacts: Average number of contacts per agent in the random network.\n    init_prev: Initial proportion of the population that is infected.\n    beta: Probability of transmission between contacts.\n\nReturns:\n    A Starsim Sim object that has been run to completion.", "background": "The SIR (susceptible-infectious-recovered) model is a fundamental compartmental model in epidemiology. Individuals start as susceptible (S), become infected (I) upon contact with an infectious individual, and eventually recover (R) with permanent immunity. In Starsim, disease dynamics are configured via the 'diseases' parameter, and agent interactions are governed by contact networks.", "dependencies": ["starsim"], "test_cases": [{"description": "Simulation should have an SIR disease", "test": "sim = create_sir_sim()\nassert hasattr(sim.diseases, 'sir'), 'Simulation should have an SIR disease'"}, {"description": "Simulation should have results after running", "test": "sim = create_sir_sim()\nassert sim.results.sir.cum_infections[-1] > 0, 'There should be at least some infections'"}, {"description": "Population size should match n_agents parameter", "test": "sim = create_sir_sim(n_agents=500)\nassert sim.pars.n_agents == 500, 'Population size should match the n_agents parameter'"}, {"description": "SIR compartments should be present in results", "test": "sim = create_sir_sim()\nassert 'n_susceptible' in sim.results.sir, 'Results should contain n_susceptible'\nassert 'n_infected' in sim.results.sir, 'Results should contain n_infected'\nassert 'n_recovered' in sim.results.sir, 'Results should contain n_recovered'"}], "gold_solution": "def create_sir_sim(n_agents: int = 10_000, n_contacts: int = 10, init_prev: float = 0.01, beta: float = 0.05) -> ss.Sim:\n    import starsim as ss\n    pars = dict(\n        n_agents=n_agents,\n        networks=dict(type='random', n_contacts=n_contacts),\n        diseases=dict(type='sir', init_prev=init_prev, beta=beta),\n    )\n    sim = ss.Sim(pars)\n    sim.run()\n    return sim"}
{"problem_id": "starsim_t1", "sub_step_id": "starsim_t1.2", "description": "Modify the basic simulation to model SIS (susceptible-infectious-susceptible) dynamics instead of SIR. In an SIS model, individuals do not gain permanent immunity after infection — they return to the susceptible state and can be reinfected.", "function_header": "def create_sis_sim(n_agents: int = 10_000, n_contacts: int = 10, init_prev: float = 0.01, beta: float = 0.05) -> ss.Sim:", "docstring": "Create and run an SIS disease simulation using Starsim.\n\nArgs:\n    n_agents: Number of agents to simulate.\n    n_contacts: Average number of contacts per agent in the random network.\n    init_prev: Initial proportion of the population that is infected.\n    beta: Probability of transmission between contacts.\n\nReturns:\n    A Starsim Sim object that has been run to completion with an SIS disease.", "background": "The SIS (susceptible-infectious-susceptible) model differs from SIR in that recovered individuals return to the susceptible compartment instead of gaining permanent immunity. This is appropriate for diseases where immunity is temporary or nonexistent (e.g., bacterial infections, some STIs). In Starsim, switching between SIR and SIS requires changing the disease type parameter.", "dependencies": ["starsim"], "test_cases": [{"description": "Simulation should have an SIS disease (not SIR)", "test": "sim = create_sis_sim()\nassert hasattr(sim.diseases, 'sis'), 'Simulation should have an SIS disease'\nassert not hasattr(sim.diseases, 'sir'), 'Simulation should NOT have an SIR disease'"}, {"description": "SIS results should not have a recovered compartment", "test": "sim = create_sis_sim()\nassert 'n_recovered' not in sim.results.sis, 'SIS model should not have a recovered compartment'"}, {"description": "SIS model should have cumulative infections", "test": "sim = create_sis_sim()\nassert sim.results.sis.cum_infections[-1] > 0, 'There should be infections in the SIS model'"}], "gold_solution": "def create_sis_sim(n_agents: int = 10_000, n_contacts: int = 10, init_prev: float = 0.01, beta: float = 0.05) -> ss.Sim:\n    import starsim as ss\n    pars = dict(\n        n_agents=n_agents,\n        networks=dict(type='random', n_contacts=n_contacts),\n        diseases=dict(type='sis', init_prev=init_prev, beta=beta),\n    )\n    sim = ss.Sim(pars)\n    sim.run()\n    return sim"}
{"problem_id": "starsim_t1", "sub_step_id": "starsim_t1.3", "description": "Explore how the transmission rate (beta) affects disease dynamics. Run multiple SIR simulations with different beta values and compare the cumulative number of infections. Higher beta values should lead to faster, larger epidemics.", "function_header": "def compare_beta(betas: list[float], n_agents: int = 10_000, n_contacts: int = 10, init_prev: float = 0.01) -> dict[float, float]:", "docstring": "Run SIR simulations with different transmission rates and compare outcomes.\n\nArgs:\n    betas: List of transmission probabilities to compare (e.g., [0.02, 0.05, 0.10]).\n    n_agents: Number of agents to simulate.\n    n_contacts: Average number of contacts per agent.\n    init_prev: Initial proportion infected.\n\nReturns:\n    Dictionary mapping each beta value to the cumulative number of infections\n    at the end of the simulation.", "background": "The transmission rate beta is a key parameter in disease modeling that controls how easily the disease spreads between contacts. Higher beta values mean each contact between a susceptible and infectious individual is more likely to result in transmission. This directly affects the basic reproduction number (R0) and the final size of the epidemic.", "dependencies": ["starsim"], "test_cases": [{"description": "Results should contain an entry for each beta value", "test": "results = compare_beta([0.02, 0.05, 0.10])\nassert set(results.keys()) == {0.02, 0.05, 0.10}, 'Should have results for all beta values'"}, {"description": "Higher beta should generally produce more cumulative infections", "test": "results = compare_beta([0.01, 0.10], n_agents=10_000)\nassert results[0.10] > results[0.01], 'Higher beta should produce more infections'"}, {"description": "All infection counts should be positive", "test": "results = compare_beta([0.02, 0.05, 0.10])\nassert all(v > 0 for v in results.values()), 'All simulations should produce some infections'"}], "gold_solution": "def compare_beta(betas: list[float], n_agents: int = 10_000, n_contacts: int = 10, init_prev: float = 0.01) -> dict[float, float]:\n    import starsim as ss\n    results = {}\n    for beta in betas:\n        pars = dict(\n            n_agents=n_agents,\n            networks=dict(type='random', n_contacts=n_contacts),\n            diseases=dict(type='sir', init_prev=init_prev, beta=beta),\n        )\n        sim = ss.Sim(pars)\n        sim.run()\n        results[beta] = float(sim.results.sir.cum_infections[-1])\n    return results"}
{"problem_id": "starsim_t1", "sub_step_id": "starsim_t1.4", "description": "Investigate how population size affects simulation results. Run SIR simulations with different numbers of agents and compare the results. Smaller populations produce noisier (less smooth) epidemic curves due to greater stochastic variation.", "function_header": "def compare_population_sizes(n_agents_list: list[int], n_contacts: int = 10, init_prev: float = 0.01, beta: float = 0.05) -> dict[int, dict]:", "docstring": "Run SIR simulations with different population sizes and compare outcomes.\n\nArgs:\n    n_agents_list: List of population sizes to compare (e.g., [200, 10_000]).\n    n_contacts: Average number of contacts per agent.\n    init_prev: Initial proportion infected.\n    beta: Probability of transmission between contacts.\n\nReturns:\n    Dictionary mapping each population size to a dict containing:\n        - 'cum_infections': cumulative infections at end of simulation\n        - 'peak_prevalence': maximum prevalence observed during the simulation", "background": "Agent-based models like Starsim are stochastic — each simulation run produces slightly different results due to random variation. With large populations, individual random events average out and curves appear smooth. With small populations, random effects are more pronounced, leading to noisier curves. This is an important consideration when choosing population size for modeling studies.", "dependencies": ["starsim"], "test_cases": [{"description": "Results should contain an entry for each population size", "test": "results = compare_population_sizes([200, 5_000])\nassert set(results.keys()) == {200, 5_000}, 'Should have results for all population sizes'"}, {"description": "Each result should contain cum_infections and peak_prevalence", "test": "results = compare_population_sizes([1_000])\nassert 'cum_infections' in results[1_000], 'Should contain cum_infections'\nassert 'peak_prevalence' in results[1_000], 'Should contain peak_prevalence'"}, {"description": "Cumulative infections should be positive for all population sizes", "test": "results = compare_population_sizes([200, 5_000])\nassert all(r['cum_infections'] > 0 for r in results.values()), 'All simulations should produce infections'"}, {"description": "Peak prevalence should be between 0 and 1", "test": "results = compare_population_sizes([1_000])\nassert 0 < results[1_000]['peak_prevalence'] <= 1.0, 'Peak prevalence should be a valid proportion'"}], "gold_solution": "def compare_population_sizes(n_agents_list: list[int], n_contacts: int = 10, init_prev: float = 0.01, beta: float = 0.05) -> dict[int, dict]:\n    import starsim as ss\n    import numpy as np\n    results = {}\n    for n_agents in n_agents_list:\n        pars = dict(\n            n_agents=n_agents,\n            networks=dict(type='random', n_contacts=n_contacts),\n            diseases=dict(type='sir', init_prev=init_prev, beta=beta),\n        )\n        sim = ss.Sim(pars)\n        sim.run()\n        prevalence = sim.results.sir.prevalence\n        results[n_agents] = {\n            'cum_infections': float(sim.results.sir.cum_infections[-1]),\n            'peak_prevalence': float(np.max(prevalence)),\n        }\n    return results"}
