{"problem_id": "starsim_t5", "sub_step_id": "starsim_t5.1", "description": "Create and run an SIR simulation using an explicit RandomNet network object. Unlike passing a string or dict for the network, this approach instantiates the network directly, giving more control over network parameters. After running the simulation, extract basic network statistics: the number of edges in the network and the number of unique contacts for agent 0.", "function_header": "def create_random_net_sim(n_agents: int = 5_000, n_contacts: int = 10, beta: float = 0.05, init_prev: float = 0.01) -> dict:", "docstring": "Create and run an SIR simulation with an explicit RandomNet, then extract network info.\n\nArgs:\n    n_agents: Number of agents to simulate.\n    n_contacts: Average number of contacts per agent in the random network.\n    beta: Probability of transmission between contacts.\n    init_prev: Initial proportion of the population that is infected.\n\nReturns:\n    Dictionary containing:\n        - 'sim': The completed Starsim Sim object.\n        - 'n_edges': Total number of edges in the random network (int).\n        - 'contacts_agent_0': Number of unique contacts of agent 0 (int).", "background": "Starsim supports several ways to specify contact networks. The most explicit is to create a network object directly (e.g., ss.RandomNet(n_contacts=10)) and pass it to the simulation. After running, the network is accessible via sim.networks.randomnet. The find_contacts() method returns an array of UIDs that a given agent is connected to. The network's to_df() method converts edges to a pandas DataFrame with columns p1, p2, and beta.", "dependencies": ["starsim"], "test_cases": [{"description": "Simulation should have a randomnet network", "test": "result = create_random_net_sim()\nassert hasattr(result['sim'].networks, 'randomnet'), 'Simulation should have a randomnet network'"}, {"description": "Network should have edges", "test": "result = create_random_net_sim()\nassert result['n_edges'] > 0, 'Network should have edges'"}, {"description": "Agent 0 should have contacts", "test": "result = create_random_net_sim()\nassert result['contacts_agent_0'] > 0, 'Agent 0 should have at least one contact'"}, {"description": "Simulation should produce infections", "test": "result = create_random_net_sim()\nassert result['sim'].results.sir.cum_infections[-1] > 0, 'There should be at least some infections'"}], "gold_solution": "def create_random_net_sim(n_agents: int = 5_000, n_contacts: int = 10, beta: float = 0.05, init_prev: float = 0.01) -> dict:\n    import starsim as ss\n    net = ss.RandomNet(n_contacts=n_contacts)\n    sir = ss.SIR(beta=beta, init_prev=init_prev)\n    sim = ss.Sim(n_agents=n_agents, diseases=sir, networks=net)\n    sim.run()\n    network = sim.networks.randomnet\n    contacts = network.find_contacts([0])\n    return {\n        'sim': sim,\n        'n_edges': len(network.to_df()),\n        'contacts_agent_0': len(contacts),\n    }"}
{"problem_id": "starsim_t5", "sub_step_id": "starsim_t5.2", "description": "Investigate how network density (average number of contacts per agent) affects SIR epidemic dynamics. Run simulations with different n_contacts values using explicit RandomNet objects. Higher contact density means each infected agent can transmit to more neighbors, leading to faster and larger epidemics.", "function_header": "def compare_network_density(n_contacts_list: list[int], n_agents: int = 5_000, beta: float = 0.05, init_prev: float = 0.01) -> dict[int, dict]:", "docstring": "Run SIR simulations with different network densities and compare outcomes.\n\nArgs:\n    n_contacts_list: List of average contact counts to compare (e.g., [4, 10, 20]).\n    n_agents: Number of agents to simulate.\n    beta: Probability of transmission between contacts.\n    init_prev: Initial proportion of the population that is infected.\n\nReturns:\n    Dictionary mapping each n_contacts value to a dict containing:\n        - 'cum_infections': cumulative infections at end of simulation\n        - 'peak_prevalence': maximum prevalence observed during the simulation", "background": "In network epidemiology, the average number of contacts (node degree) is a key determinant of epidemic dynamics. Higher contact density increases the effective reproduction number, making it easier for the disease to spread. In Starsim, this is controlled via the n_contacts parameter of ss.RandomNet. With low density, epidemics may fail to take off or remain small. With high density, epidemics spread rapidly through the population.", "dependencies": ["starsim", "numpy"], "test_cases": [{"description": "Results should contain an entry for each n_contacts value", "test": "results = compare_network_density([4, 10, 20])\nassert set(results.keys()) == {4, 10, 20}, 'Should have results for all n_contacts values'"}, {"description": "Each result should contain cum_infections and peak_prevalence", "test": "results = compare_network_density([10])\nassert 'cum_infections' in results[10], 'Should contain cum_infections'\nassert 'peak_prevalence' in results[10], 'Should contain peak_prevalence'"}, {"description": "Higher network density should produce more cumulative infections", "test": "results = compare_network_density([4, 20], n_agents=5_000)\nassert results[20]['cum_infections'] > results[4]['cum_infections'], 'Denser network should produce more infections'"}, {"description": "Peak prevalence should be between 0 and 1", "test": "results = compare_network_density([10])\nassert 0 < results[10]['peak_prevalence'] <= 1.0, 'Peak prevalence should be a valid proportion'"}], "gold_solution": "def compare_network_density(n_contacts_list: list[int], n_agents: int = 5_000, beta: float = 0.05, init_prev: float = 0.01) -> dict[int, dict]:\n    import starsim as ss\n    import numpy as np\n    results = {}\n    for nc in n_contacts_list:\n        net = ss.RandomNet(n_contacts=nc)\n        sir = ss.SIR(beta=beta, init_prev=init_prev)\n        sim = ss.Sim(n_agents=n_agents, diseases=sir, networks=net)\n        sim.run()\n        results[nc] = {\n            'cum_infections': float(sim.results.sir.cum_infections[-1]),\n            'peak_prevalence': float(np.max(sim.results.sir.prevalence)),\n        }\n    return results"}
{"problem_id": "starsim_t5", "sub_step_id": "starsim_t5.3", "description": "Create an STI (sexually transmitted infection) model using Starsim's MFNet, a sexual network that forms partnerships between male and female agents. MFNet models heterosexual pair formation with configurable relationship duration and coital act frequency. Use an SIS disease (appropriate for bacterial STIs where reinfection is possible) transmitted over this network.", "function_header": "def create_mfnet_sim(n_agents: int = 2_000, beta: float = 0.5, init_prev: float = 0.1, dur: int = 20) -> ss.Sim:", "docstring": "Create and run an SIS simulation over an MFNet sexual network.\n\nArgs:\n    n_agents: Number of agents to simulate.\n    beta: Probability of transmission per contact.\n    init_prev: Initial proportion of the population that is infected.\n    dur: Duration of the simulation in years.\n\nReturns:\n    A Starsim Sim object that has been run to completion with an SIS disease\n    transmitted over an MFNet network.", "background": "Starsim provides specialized network types for modeling sexually transmitted infections. ss.MFNet creates a heterosexual (male-female) partnership network where agents form and dissolve relationships over time. Key parameters include 'duration' (average relationship length) and 'acts' (coital acts per year). For STI modeling, SIS dynamics are often appropriate since many bacterial STIs (e.g., gonorrhea, chlamydia) do not confer lasting immunity. The simulation requires sub-annual timesteps (e.g., dt=1/12 for monthly) to capture partnership dynamics.", "dependencies": ["starsim"], "test_cases": [{"description": "Simulation should have an MFNet network", "test": "sim = create_mfnet_sim()\nassert hasattr(sim.networks, 'mfnet'), 'Simulation should have an mfnet network'"}, {"description": "Simulation should have an SIS disease", "test": "sim = create_mfnet_sim()\nassert hasattr(sim.diseases, 'sis'), 'Simulation should have an SIS disease'"}, {"description": "Simulation should produce infections", "test": "sim = create_mfnet_sim()\nassert sim.results.sis.cum_infections[-1] > 0, 'There should be at least some infections'"}, {"description": "Network should have partnership edges", "test": "sim = create_mfnet_sim()\ndf = sim.networks.mfnet.to_df()\nassert len(df) > 0, 'MFNet should have active partnerships'"}], "gold_solution": "def create_mfnet_sim(n_agents: int = 2_000, beta: float = 0.5, init_prev: float = 0.1, dur: int = 20) -> ss.Sim:\n    import starsim as ss\n    mf = ss.MFNet()\n    sis = ss.SIS(beta=beta, init_prev=init_prev)\n    sim = ss.Sim(n_agents=n_agents, diseases=sis, networks=mf, start=2000, dur=dur, dt=1/12)\n    sim.run()\n    return sim"}
{"problem_id": "starsim_t5", "sub_step_id": "starsim_t5.4", "description": "Compare two approaches to modeling disease transmission in Starsim: contact networks (RandomNet) and mixing pools (MixingPool). Contact networks track individual edges between agents, while mixing pools use a well-mixed approximation where transmission depends on the average level of infection in the pool. Run an SIR simulation with each approach and compare their epidemic outcomes.", "function_header": "def compare_network_types(n_agents: int = 5_000, n_contacts: int = 4, init_prev: float = 0.01) -> dict[str, dict]:", "docstring": "Compare SIR epidemic outcomes using a RandomNet vs a MixingPool.\n\nArgs:\n    n_agents: Number of agents to simulate.\n    n_contacts: Average number of contacts (used for both network types).\n    init_prev: Initial proportion of the population that is infected.\n\nReturns:\n    Dictionary with two keys:\n        - 'mixing_pool': dict with 'cum_infections' and 'peak_prevalence'\n        - 'random_net': dict with 'cum_infections' and 'peak_prevalence'", "background": "Starsim provides two fundamentally different approaches for modeling contacts. ss.RandomNet creates explicit person-to-person edges and transmits disease along those edges using the disease's beta parameter. ss.MixingPool instead computes transmission based on the average infectious fraction in the pool â€” it does not track individual contacts. MixingPool takes its own beta parameter (separate from the disease beta) controlling the force of infection. The two approaches can produce similar epidemic dynamics with appropriate parameterization, but MixingPool is computationally cheaper for large populations. Use ss.poisson(lam=n) to set the number of contacts as a Poisson-distributed random variable.", "dependencies": ["starsim", "numpy"], "test_cases": [{"description": "Results should contain mixing_pool and random_net keys", "test": "results = compare_network_types()\nassert 'mixing_pool' in results, 'Should have mixing_pool results'\nassert 'random_net' in results, 'Should have random_net results'"}, {"description": "Each result should contain cum_infections and peak_prevalence", "test": "results = compare_network_types()\nfor key in ['mixing_pool', 'random_net']:\n    assert 'cum_infections' in results[key], f'{key} should contain cum_infections'\n    assert 'peak_prevalence' in results[key], f'{key} should contain peak_prevalence'"}, {"description": "Both approaches should produce infections", "test": "results = compare_network_types()\nassert results['mixing_pool']['cum_infections'] > 0, 'MixingPool should produce infections'\nassert results['random_net']['cum_infections'] > 0, 'RandomNet should produce infections'"}, {"description": "Peak prevalence should be valid proportions", "test": "results = compare_network_types()\nfor key in ['mixing_pool', 'random_net']:\n    assert 0 < results[key]['peak_prevalence'] <= 1.0, f'{key} peak prevalence should be a valid proportion'"}], "gold_solution": "def compare_network_types(n_agents: int = 5_000, n_contacts: int = 4, init_prev: float = 0.01) -> dict[str, dict]:\n    import starsim as ss\n    import numpy as np\n\n    # Mixing pool approach\n    mp = ss.MixingPool(n_contacts=ss.poisson(lam=n_contacts))\n    sir_mp = ss.SIR(init_prev=init_prev)\n    sim_mp = ss.Sim(n_agents=n_agents, diseases=sir_mp, networks=mp)\n    sim_mp.run()\n\n    # Contact network approach\n    net = ss.RandomNet(n_contacts=n_contacts)\n    sir_net = ss.SIR(beta=0.05, init_prev=init_prev)\n    sim_net = ss.Sim(n_agents=n_agents, diseases=sir_net, networks=net)\n    sim_net.run()\n\n    return {\n        'mixing_pool': {\n            'cum_infections': float(sim_mp.results.sir.cum_infections[-1]),\n            'peak_prevalence': float(np.max(sim_mp.results.sir.prevalence)),\n        },\n        'random_net': {\n            'cum_infections': float(sim_net.results.sir.cum_infections[-1]),\n            'peak_prevalence': float(np.max(sim_net.results.sir.prevalence)),\n        },\n    }"}
