{"problem_id": "starsim_t2", "sub_step_id": "starsim_t2.1", "description": "Create and run an SIR simulation using Starsim's component-based approach. Instead of passing a parameters dictionary, instantiate individual component objects (ss.People, ss.RandomNet, ss.SIR) and pass them directly to ss.Sim. This approach provides greater flexibility for configuring and reusing model components.", "function_header": "def create_component_sim(n_agents: int = 5_000, n_contacts: int = 4, init_prev: float = 0.1, beta: float = 0.1) -> ss.Sim:", "docstring": "Create and run an SIR simulation using Starsim's component-based approach.\n\nInstead of using a parameters dictionary, create individual component objects\n(ss.People, ss.RandomNet, ss.SIR) and pass them to ss.Sim.\n\nArgs:\n    n_agents: Number of agents to simulate.\n    n_contacts: Average number of contacts per agent in the random network.\n    init_prev: Initial proportion of the population that is infected.\n    beta: Probability of transmission between contacts.\n\nReturns:\n    A Starsim Sim object that has been run to completion.", "background": "Starsim supports two ways of configuring simulations. The dictionary approach bundles all parameters into a single dict, while the component-based approach creates individual objects (People, Networks, Diseases) that are passed to the Sim constructor. The component approach is preferred for complex models because each component can be configured independently and reused across simulations.", "dependencies": ["starsim"], "test_cases": [{"description": "Simulation should use an SIR disease via component objects", "test": "sim = create_component_sim()\nassert hasattr(sim.diseases, 'sir'), 'Simulation should have an SIR disease'"}, {"description": "Disease should be instantiated as an ss.SIR object", "test": "import starsim as ss\nsim = create_component_sim()\ndisease = list(sim.diseases.values())[0]\nassert isinstance(disease, ss.SIR), 'Disease should be an ss.SIR instance'"}, {"description": "Network should be instantiated as an ss.RandomNet object", "test": "import starsim as ss\nsim = create_component_sim()\nnetwork = list(sim.networks.values())[0]\nassert isinstance(network, ss.RandomNet), 'Network should be an ss.RandomNet instance'"}, {"description": "Simulation should produce infections", "test": "sim = create_component_sim()\nassert sim.results.sir.cum_infections[-1] > 0, 'There should be at least some infections'"}, {"description": "Population size should match n_agents parameter", "test": "sim = create_component_sim(n_agents=1_000)\nassert sim.pars.n_agents == 1_000, 'Population size should match the n_agents parameter'"}], "gold_solution": "def create_component_sim(n_agents: int = 5_000, n_contacts: int = 4, init_prev: float = 0.1, beta: float = 0.1) -> ss.Sim:\n    import starsim as ss\n    people = ss.People(n_agents=n_agents)\n    network = ss.RandomNet(n_contacts=n_contacts)\n    sir = ss.SIR(init_prev=init_prev, beta=beta)\n    sim = ss.Sim(people=people, diseases=sir, networks=network)\n    sim.run()\n    return sim"}
{"problem_id": "starsim_t2", "sub_step_id": "starsim_t2.2", "description": "Create a simulation with heterogeneous contact patterns by using a Poisson-distributed number of contacts instead of a fixed value. In real populations, the number of contacts varies from person to person. Starsim's distribution objects (e.g., ss.poisson) let you model this variation.", "function_header": "def create_heterogeneous_sim(n_agents: int = 5_000, mean_contacts: int = 4, init_prev: float = 0.1, beta: float = 0.1) -> ss.Sim:", "docstring": "Create and run an SIR simulation with heterogeneous (Poisson-distributed) contacts.\n\nArgs:\n    n_agents: Number of agents to simulate.\n    mean_contacts: Mean number of contacts per agent (lambda for Poisson distribution).\n    init_prev: Initial proportion of the population that is infected.\n    beta: Probability of transmission between contacts.\n\nReturns:\n    A Starsim Sim object that has been run to completion.", "background": "In real populations, the number of contacts varies across individuals. Some people have many contacts while others have few. This heterogeneity affects disease spread because highly connected individuals can act as super-spreaders. Starsim supports this via distribution objects like ss.poisson(lam), which draws a different number of contacts for each agent from a Poisson distribution with the given mean.", "dependencies": ["starsim"], "test_cases": [{"description": "Simulation should have an SIR disease", "test": "sim = create_heterogeneous_sim()\nassert hasattr(sim.diseases, 'sir'), 'Simulation should have an SIR disease'"}, {"description": "Network should be a RandomNet", "test": "import starsim as ss\nsim = create_heterogeneous_sim()\nnetwork = list(sim.networks.values())[0]\nassert isinstance(network, ss.RandomNet), 'Network should be a RandomNet'"}, {"description": "Simulation should produce infections", "test": "sim = create_heterogeneous_sim()\nassert sim.results.sir.cum_infections[-1] > 0, 'There should be at least some infections'"}, {"description": "Population size should match n_agents parameter", "test": "sim = create_heterogeneous_sim(n_agents=1_000)\nassert sim.pars.n_agents == 1_000, 'Population size should match n_agents'"}], "gold_solution": "def create_heterogeneous_sim(n_agents: int = 5_000, mean_contacts: int = 4, init_prev: float = 0.1, beta: float = 0.1) -> ss.Sim:\n    import starsim as ss\n    people = ss.People(n_agents=n_agents)\n    network = ss.RandomNet(n_contacts=ss.poisson(mean_contacts))\n    sir = ss.SIR(init_prev=init_prev, beta=beta)\n    sim = ss.Sim(people=people, diseases=sir, networks=network)\n    sim.run()\n    return sim"}
{"problem_id": "starsim_t2", "sub_step_id": "starsim_t2.3", "description": "Model an outbreak of an SIR-like disease in a refugee camp of 2,000 people over 1 year with daily timesteps. Use the component-based approach with appropriate time units (ss.days for duration of infection, ss.perday for beta). Return the cumulative number of infections at the end of the simulation.", "function_header": "def refugee_camp_outbreak(n_agents: int = 2_000, n_contacts: int = 4, init_prev: float = 0.001, beta: float = 0.02, dur_inf: int = 14) -> float:", "docstring": "Model an SIR outbreak in a refugee camp and return cumulative infections.\n\nConfigure a daily-timestep simulation running for 1 year starting from\n2025-01-01. Use ss.days() for the duration of infection and ss.perday()\nfor the transmission rate to ensure correct unit handling with daily\ntimesteps.\n\nArgs:\n    n_agents: Number of people in the refugee camp.\n    n_contacts: Average number of contacts per person.\n    init_prev: Initial proportion of the population that is infected.\n    beta: Per-day transmission probability.\n    dur_inf: Duration of infection in days.\n\nReturns:\n    Cumulative number of infections at the end of the 1-year simulation.", "background": "When modeling outbreaks at daily resolution, parameter units must match the timestep. Starsim provides unit-aware helpers: ss.days(n) specifies a duration in days, and ss.perday(rate) specifies a per-day rate. These ensure correct behavior regardless of the simulation's dt setting. For a refugee camp scenario, daily timesteps capture rapid outbreak dynamics that annual timesteps would miss.", "dependencies": ["starsim"], "test_cases": [{"description": "Should return a positive number of cumulative infections", "test": "result = refugee_camp_outbreak()\nassert result > 0, 'Should have at least some infections'"}, {"description": "Return value should be a float", "test": "result = refugee_camp_outbreak()\nassert isinstance(result, float), 'Should return a float'"}, {"description": "Cumulative infections should not exceed population size", "test": "n = 2_000\nresult = refugee_camp_outbreak(n_agents=n)\nassert result <= n, 'Cumulative infections should not exceed population size'"}, {"description": "Higher beta should produce more infections", "test": "low = refugee_camp_outbreak(n_agents=2_000, beta=0.005)\nhigh = refugee_camp_outbreak(n_agents=2_000, beta=0.05)\nassert high > low, 'Higher beta should produce more infections'"}], "gold_solution": "def refugee_camp_outbreak(n_agents: int = 2_000, n_contacts: int = 4, init_prev: float = 0.001, beta: float = 0.02, dur_inf: int = 14) -> float:\n    import starsim as ss\n    people = ss.People(n_agents=n_agents)\n    network = ss.RandomNet(n_contacts=n_contacts)\n    sir = ss.SIR(dur_inf=ss.days(dur_inf), beta=ss.perday(beta), init_prev=init_prev)\n    sim = ss.Sim(people=people, diseases=sir, networks=network, start='2025-01-01', dur=365, dt='day')\n    sim.run()\n    return float(sim.results.sir.cum_infections[-1])"}
{"problem_id": "starsim_t2", "sub_step_id": "starsim_t2.4", "description": "Explore how different epidemic drivers affect outbreak size. Run SIR simulations varying beta (transmissibility), n_contacts (contact rate), and dur_inf (duration of infection) to understand how each factor independently influences the cumulative number of infections. Return a dictionary of results for each parameter sweep.", "function_header": "def explore_epidemic_drivers(betas: list[float] = [0.01, 0.05, 0.10], n_contacts_list: list[int] = [2, 4, 8], dur_infs: list[int] = [5, 10, 20], n_agents: int = 5_000) -> dict[str, dict]:", "docstring": "Run SIR simulations varying key epidemic parameters and compare outcomes.\n\nFor each parameter sweep, hold all other parameters at their defaults\n(beta=0.05, n_contacts=4, dur_inf=10) and vary only the target parameter.\n\nArgs:\n    betas: List of transmission probabilities to sweep.\n    n_contacts_list: List of contact rates to sweep.\n    dur_infs: List of infection durations (in days) to sweep.\n    n_agents: Number of agents per simulation.\n\nReturns:\n    Dictionary with three keys:\n        - 'beta': dict mapping each beta value to cumulative infections\n        - 'n_contacts': dict mapping each n_contacts value to cumulative infections\n        - 'dur_inf': dict mapping each dur_inf value to cumulative infections", "background": "The basic reproduction number R0 — the average number of secondary infections from a single case in a fully susceptible population — depends on the transmissibility (beta), contact rate (c), and duration of infection (D): R0 = beta * c * D. By sweeping each parameter independently while holding the others fixed, you can see how each factor drives epidemic size. This is a fundamental exercise in understanding infectious disease dynamics.", "dependencies": ["starsim"], "test_cases": [{"description": "Result should contain beta, n_contacts, and dur_inf keys", "test": "results = explore_epidemic_drivers()\nassert set(results.keys()) == {'beta', 'n_contacts', 'dur_inf'}, 'Should have beta, n_contacts, and dur_inf keys'"}, {"description": "Beta sweep should have correct keys", "test": "results = explore_epidemic_drivers(betas=[0.01, 0.10])\nassert set(results['beta'].keys()) == {0.01, 0.10}, 'Beta sweep should have entries for each beta value'"}, {"description": "Contact sweep should have correct keys", "test": "results = explore_epidemic_drivers(n_contacts_list=[2, 8])\nassert set(results['n_contacts'].keys()) == {2, 8}, 'Contact sweep should have entries for each n_contacts value'"}, {"description": "Duration sweep should have correct keys", "test": "results = explore_epidemic_drivers(dur_infs=[5, 20])\nassert set(results['dur_inf'].keys()) == {5, 20}, 'Duration sweep should have entries for each dur_inf value'"}, {"description": "Higher beta should generally produce more infections", "test": "results = explore_epidemic_drivers(betas=[0.01, 0.10], n_agents=5_000)\nassert results['beta'][0.10] > results['beta'][0.01], 'Higher beta should produce more infections'"}, {"description": "More contacts should generally produce more infections", "test": "results = explore_epidemic_drivers(n_contacts_list=[2, 8], n_agents=5_000)\nassert results['n_contacts'][8] > results['n_contacts'][2], 'More contacts should produce more infections'"}, {"description": "All infection counts should be non-negative", "test": "results = explore_epidemic_drivers()\nfor sweep_name, sweep in results.items():\n    for param_val, count in sweep.items():\n        assert count >= 0, f'{sweep_name}={param_val} should have non-negative infections'"}], "gold_solution": "def explore_epidemic_drivers(betas: list[float] = [0.01, 0.05, 0.10], n_contacts_list: list[int] = [2, 4, 8], dur_infs: list[int] = [5, 10, 20], n_agents: int = 5_000) -> dict[str, dict]:\n    import starsim as ss\n    results = {'beta': {}, 'n_contacts': {}, 'dur_inf': {}}\n    # Sweep beta\n    for beta in betas:\n        sir = ss.SIR(init_prev=0.01, beta=beta, dur_inf=10)\n        sim = ss.Sim(people=ss.People(n_agents=n_agents), diseases=sir, networks=ss.RandomNet(n_contacts=4))\n        sim.run()\n        results['beta'][beta] = float(sim.results.sir.cum_infections[-1])\n    # Sweep n_contacts\n    for nc in n_contacts_list:\n        sir = ss.SIR(init_prev=0.01, beta=0.05, dur_inf=10)\n        sim = ss.Sim(people=ss.People(n_agents=n_agents), diseases=sir, networks=ss.RandomNet(n_contacts=nc))\n        sim.run()\n        results['n_contacts'][nc] = float(sim.results.sir.cum_infections[-1])\n    # Sweep dur_inf\n    for di in dur_infs:\n        sir = ss.SIR(init_prev=0.01, beta=0.05, dur_inf=di)\n        sim = ss.Sim(people=ss.People(n_agents=n_agents), diseases=sir, networks=ss.RandomNet(n_contacts=4))\n        sim.run()\n        results['dur_inf'][di] = float(sim.results.sir.cum_infections[-1])\n    return results"}
