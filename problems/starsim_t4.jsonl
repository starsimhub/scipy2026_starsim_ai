{"problem_id": "starsim_t4", "sub_step_id": "starsim_t4.1", "description": "Explore how disease-induced mortality (p_death) affects SIR epidemic outcomes. Run multiple SIR simulations with different mortality probabilities and compare the cumulative number of infections and final number of recovered agents. Higher mortality should reduce the recovered population since more infected agents die.", "function_header": "def compare_mortality_rates(p_deaths: list[float], n_agents: int = 5_000, beta: float = 0.2, init_prev: float = 0.1, dur_inf: float = 10) -> dict[float, dict]:", "docstring": "Run SIR simulations with different mortality rates and compare outcomes.\n\nArgs:\n    p_deaths: List of mortality probabilities to compare (e.g., [0.0, 0.2, 0.5]).\n    n_agents: Number of agents to simulate.\n    beta: Probability of transmission between contacts.\n    init_prev: Initial proportion of the population that is infected.\n    dur_inf: Duration of infection in years.\n\nReturns:\n    Dictionary mapping each p_death value to a dict containing:\n        - 'cum_infections': cumulative infections at end of simulation\n        - 'n_recovered': number of recovered agents at end of simulation", "background": "The p_death parameter in Starsim's SIR model controls the probability that an infected agent dies from the disease instead of recovering. When p_death is 0, all infected agents eventually recover. When p_death is positive, a fraction of infected agents die, reducing the recovered population. This parameter is important for modeling diseases with significant case fatality rates. Disease parameters like dur_inf, beta, init_prev, and p_death can be passed directly to ss.SIR().", "dependencies": ["starsim"], "test_cases": [{"description": "Results should contain an entry for each p_death value", "test": "results = compare_mortality_rates([0.0, 0.2, 0.5])\nassert set(results.keys()) == {0.0, 0.2, 0.5}, 'Should have results for all p_death values'"}, {"description": "Each result should contain cum_infections and n_recovered", "test": "results = compare_mortality_rates([0.0])\nassert 'cum_infections' in results[0.0], 'Should contain cum_infections'\nassert 'n_recovered' in results[0.0], 'Should contain n_recovered'"}, {"description": "Higher mortality should produce fewer recovered agents", "test": "results = compare_mortality_rates([0.0, 0.5], n_agents=5_000)\nassert results[0.0]['n_recovered'] > results[0.5]['n_recovered'], 'Higher mortality should reduce the recovered count'"}, {"description": "All simulations should produce infections", "test": "results = compare_mortality_rates([0.0, 0.2, 0.5])\nassert all(v['cum_infections'] > 0 for v in results.values()), 'All simulations should produce some infections'"}], "gold_solution": "def compare_mortality_rates(p_deaths: list[float], n_agents: int = 5_000, beta: float = 0.2, init_prev: float = 0.1, dur_inf: float = 10) -> dict[float, dict]:\n    import starsim as ss\n    results = {}\n    for pd in p_deaths:\n        sir = ss.SIR(beta=beta, init_prev=init_prev, dur_inf=dur_inf, p_death=pd)\n        sim = ss.Sim(n_agents=n_agents, diseases=sir, networks='random')\n        sim.run()\n        results[pd] = {\n            'cum_infections': float(sim.results.sir.cum_infections[-1]),\n            'n_recovered': float(sim.results.sir.n_recovered[-1]),\n        }\n    return results"}
{"problem_id": "starsim_t4", "sub_step_id": "starsim_t4.2", "description": "Create a custom SEIR (susceptible-exposed-infectious-recovered) disease model by subclassing Starsim's built-in SIR model. The SEIR model adds an exposed (latent) compartment: after transmission, agents enter an exposed state before becoming infectious. Define the new class with appropriate states, parameters, and state transition logic, then run a simulation with it.", "function_header": "def create_seir_sim(n_agents: int = 5_000, beta: float = 0.1, init_prev: float = 0.05, dur_exp: float = 0.5, dur_inf: float = 10, p_death: float = 0.0) -> ss.Sim:", "docstring": "Create and run a simulation with a custom SEIR disease model.\n\nDefine an SEIR class that extends ss.SIR by adding an exposed compartment.\nNew agents who are infected first become exposed, then transition to infectious\nafter a latent period (dur_exp). The class should:\n  - Add an 'exposed' BoolState and 'ti_exposed' FloatArr state\n  - Add a 'dur_exp' parameter (using ss.lognorm_ex distribution)\n  - Override set_prognoses to route new infections through the exposed state\n  - Override step_state to handle exposed -> infected transitions\n  - Override step_die to clear the exposed state for dying agents\n\nArgs:\n    n_agents: Number of agents to simulate.\n    beta: Probability of transmission between contacts.\n    init_prev: Initial proportion of the population that is infected.\n    dur_exp: Mean duration of the exposed (latent) period in years.\n    dur_inf: Duration of infection in years.\n    p_death: Probability of death among infected agents.\n\nReturns:\n    A Starsim Sim object that has been run to completion with the SEIR disease.", "background": "The SEIR model extends SIR by adding an exposed (E) compartment between susceptible and infectious. This represents a latent period during which an agent has been infected but is not yet (fully) infectious. In Starsim, custom disease models are created by subclassing existing ones (e.g., ss.SIR). Key methods to override include: __init__ (to add parameters and states via define_pars and define_states), set_prognoses (to schedule state transitions when infection occurs), step_state (to execute scheduled transitions each timestep), and step_die (to clean up states when agents die). The 'infectious' property determines which agents can transmit the disease.", "dependencies": ["starsim"], "test_cases": [{"description": "Simulation should have an SEIR disease", "test": "sim = create_seir_sim()\nassert hasattr(sim.diseases, 'seir'), 'Simulation should have an SEIR disease'"}, {"description": "SEIR results should include the exposed compartment", "test": "sim = create_seir_sim()\nassert 'n_exposed' in sim.results.seir, 'SEIR results should track n_exposed'"}, {"description": "Simulation should produce infections", "test": "sim = create_seir_sim()\nassert sim.results.seir.cum_infections[-1] > 0, 'There should be at least some infections'"}, {"description": "Population size should match n_agents parameter", "test": "sim = create_seir_sim(n_agents=1_000)\nassert sim.pars.n_agents == 1_000, 'Population size should match n_agents'"}], "gold_solution": "def create_seir_sim(n_agents: int = 5_000, beta: float = 0.1, init_prev: float = 0.05, dur_exp: float = 0.5, dur_inf: float = 10, p_death: float = 0.0) -> ss.Sim:\n    import starsim as ss\n\n    class SEIR(ss.SIR):\n        def __init__(self, pars=None, *args, **kwargs):\n            super().__init__()\n            self.define_pars(\n                dur_exp=ss.lognorm_ex(0.5),\n            )\n            self.update_pars(pars, **kwargs)\n            self.define_states(\n                ss.BoolState('exposed', label='Exposed'),\n                ss.FloatArr('ti_exposed', label='Time of exposure'),\n            )\n\n        @property\n        def infectious(self):\n            return self.infected | self.exposed\n\n        def step_state(self):\n            super().step_state()\n            infected = self.exposed & (self.ti_infected <= self.ti)\n            self.exposed[infected] = False\n            self.infected[infected] = True\n\n        def step_die(self, uids):\n            super().step_die(uids)\n            self.exposed[uids] = False\n\n        def set_prognoses(self, uids, sources=None):\n            super().set_prognoses(uids, sources)\n            ti = self.ti\n            self.susceptible[uids] = False\n            self.exposed[uids] = True\n            self.ti_exposed[uids] = ti\n            p = self.pars\n            dur_exp = p.dur_exp.rvs(uids)\n            self.ti_infected[uids] = ti + dur_exp\n            dur_inf = p.dur_inf.rvs(uids)\n            will_die = p.p_death.rvs(uids)\n            self.ti_recovered[uids[~will_die]] = ti + dur_inf[~will_die]\n            self.ti_dead[uids[will_die]] = ti + dur_inf[will_die]\n\n    seir = SEIR(beta=beta, init_prev=init_prev, dur_exp=dur_exp, dur_inf=dur_inf, p_death=p_death)\n    sim = ss.Sim(n_agents=n_agents, diseases=seir, networks='random')\n    sim.run()\n    return sim"}
{"problem_id": "starsim_t4", "sub_step_id": "starsim_t4.3", "description": "Investigate how varying the exposure (latent) duration affects SEIR epidemic trajectories. Run multiple SEIR simulations with different dur_exp values and compare the cumulative infections and peak number of exposed agents. Longer exposure durations delay the onset of infectiousness and can change the shape of the epidemic curve.", "function_header": "def compare_exposure_durations(dur_exps: list[float], n_agents: int = 5_000, beta: float = 0.1, init_prev: float = 0.05) -> dict[float, dict]:", "docstring": "Run SEIR simulations with different exposure durations and compare outcomes.\n\nFor each dur_exp value, create a custom SEIR model (subclassing ss.SIR with\nan exposed compartment) and run a simulation. Collect the cumulative infections\nand peak number of exposed agents.\n\nArgs:\n    dur_exps: List of mean exposure durations to compare (in years).\n    n_agents: Number of agents to simulate.\n    beta: Probability of transmission between contacts.\n    init_prev: Initial proportion of the population that is infected.\n\nReturns:\n    Dictionary mapping each dur_exp value to a dict containing:\n        - 'cum_infections': cumulative infections at end of simulation\n        - 'peak_exposed': maximum number of exposed agents during the simulation", "background": "The exposure (latent) duration in an SEIR model controls how long agents remain in the exposed state before becoming infectious. A longer latent period means there is a greater delay between transmission and infectiousness, which can slow the epidemic and change the peak timing. This is an important parameter for diseases like measles (short latent period) versus tuberculosis (long latent period). To explore this, define a custom SEIR class by subclassing ss.SIR, adding an exposed BoolState and dur_exp parameter.", "dependencies": ["starsim", "numpy"], "test_cases": [{"description": "Results should contain an entry for each dur_exp value", "test": "results = compare_exposure_durations([0.1, 0.5, 2.0])\nassert set(results.keys()) == {0.1, 0.5, 2.0}, 'Should have results for all dur_exp values'"}, {"description": "Each result should contain cum_infections and peak_exposed", "test": "results = compare_exposure_durations([0.5])\nassert 'cum_infections' in results[0.5], 'Should contain cum_infections'\nassert 'peak_exposed' in results[0.5], 'Should contain peak_exposed'"}, {"description": "All simulations should produce infections", "test": "results = compare_exposure_durations([0.1, 0.5, 2.0])\nassert all(v['cum_infections'] > 0 for v in results.values()), 'All simulations should produce infections'"}, {"description": "Peak exposed should be positive for all simulations", "test": "results = compare_exposure_durations([0.1, 0.5, 2.0])\nassert all(v['peak_exposed'] > 0 for v in results.values()), 'All simulations should have some exposed agents'"}], "gold_solution": "def compare_exposure_durations(dur_exps: list[float], n_agents: int = 5_000, beta: float = 0.1, init_prev: float = 0.05) -> dict[float, dict]:\n    import starsim as ss\n    import numpy as np\n\n    class SEIR(ss.SIR):\n        def __init__(self, pars=None, *args, **kwargs):\n            super().__init__()\n            self.define_pars(\n                dur_exp=ss.lognorm_ex(0.5),\n            )\n            self.update_pars(pars, **kwargs)\n            self.define_states(\n                ss.BoolState('exposed', label='Exposed'),\n                ss.FloatArr('ti_exposed', label='Time of exposure'),\n            )\n\n        @property\n        def infectious(self):\n            return self.infected | self.exposed\n\n        def step_state(self):\n            super().step_state()\n            infected = self.exposed & (self.ti_infected <= self.ti)\n            self.exposed[infected] = False\n            self.infected[infected] = True\n\n        def step_die(self, uids):\n            super().step_die(uids)\n            self.exposed[uids] = False\n\n        def set_prognoses(self, uids, sources=None):\n            super().set_prognoses(uids, sources)\n            ti = self.ti\n            self.susceptible[uids] = False\n            self.exposed[uids] = True\n            self.ti_exposed[uids] = ti\n            p = self.pars\n            dur_exp = p.dur_exp.rvs(uids)\n            self.ti_infected[uids] = ti + dur_exp\n            dur_inf = p.dur_inf.rvs(uids)\n            will_die = p.p_death.rvs(uids)\n            self.ti_recovered[uids[~will_die]] = ti + dur_inf[~will_die]\n            self.ti_dead[uids[will_die]] = ti + dur_inf[will_die]\n\n    results = {}\n    for de in dur_exps:\n        seir = SEIR(beta=beta, init_prev=init_prev, dur_exp=de)\n        sim = ss.Sim(n_agents=n_agents, diseases=seir, networks='random')\n        sim.run()\n        results[de] = {\n            'cum_infections': float(sim.results.seir.cum_infections[-1]),\n            'peak_exposed': float(np.max(sim.results.seir.n_exposed)),\n        }\n    return results"}
{"problem_id": "starsim_t4", "sub_step_id": "starsim_t4.4", "description": "Extend the SEIR model to implement SEIRS dynamics, where recovered individuals lose immunity after a period and return to the susceptible state. This enables recurrent epidemic waves as the population cycles through S-E-I-R-S states. Create both the SEIR and SEIRS classes and run a simulation.", "function_header": "def create_seirs_sim(n_agents: int = 5_000, beta: float = 0.2, init_prev: float = 0.1, dur_exp: float = 0.5, dur_inf: float = 5, dur_imm: float = 2.0, p_death: float = 0.0) -> ss.Sim:", "docstring": "Create and run a simulation with a custom SEIRS disease model.\n\nFirst define an SEIR class (subclassing ss.SIR with an exposed compartment),\nthen define an SEIRS class that extends SEIR by adding waning immunity.\nRecovered agents should transition back to susceptible after a period of\ndur_imm years. The SEIRS class should:\n  - Add a 'dur_imm' parameter (using ss.lognorm_ex distribution)\n  - Add a 'ti_susceptible' FloatArr state to schedule waning\n  - Override step_state to handle recovered -> susceptible transitions\n  - Override set_prognoses to schedule the waning time\n\nArgs:\n    n_agents: Number of agents to simulate.\n    beta: Probability of transmission between contacts.\n    init_prev: Initial proportion of the population that is infected.\n    dur_exp: Mean duration of the exposed (latent) period in years.\n    dur_inf: Duration of infection in years.\n    dur_imm: Mean duration of immunity before waning, in years.\n    p_death: Probability of death among infected agents.\n\nReturns:\n    A Starsim Sim object that has been run to completion with the SEIRS disease.", "background": "The SEIRS model adds waning immunity to the SEIR framework. After recovering, agents retain immunity for a period (dur_imm) before becoming susceptible again. This allows recurrent epidemics \u2014 once enough recovered agents lose immunity, the susceptible pool rebuilds and a new epidemic wave can occur. This is relevant for diseases like influenza or RSV where immunity is temporary. In Starsim, this is implemented by extending the custom SEIR class: add a dur_imm parameter and ti_susceptible FloatArr state, schedule the waning time in set_prognoses (ti_susceptible = ti_recovered + dur_imm), and handle the recovered -> susceptible transition in step_state.", "dependencies": ["starsim"], "test_cases": [{"description": "Simulation should have an SEIRS disease", "test": "sim = create_seirs_sim()\nassert hasattr(sim.diseases, 'seirs'), 'Simulation should have an SEIRS disease'"}, {"description": "Simulation should produce infections", "test": "sim = create_seirs_sim()\nassert sim.results.seirs.cum_infections[-1] > 0, 'There should be at least some infections'"}, {"description": "SEIRS results should include the exposed compartment", "test": "sim = create_seirs_sim()\nassert 'n_exposed' in sim.results.seirs, 'SEIRS results should track n_exposed'"}, {"description": "Shorter immunity duration should produce more cumulative infections", "test": "short = create_seirs_sim(n_agents=2_000, dur_imm=1.0, beta=0.2, init_prev=0.1, p_death=0.0)\nlong_ = create_seirs_sim(n_agents=2_000, dur_imm=50.0, beta=0.2, init_prev=0.1, p_death=0.0)\nassert short.results.seirs.cum_infections[-1] >= long_.results.seirs.cum_infections[-1], 'Shorter immunity should allow more reinfection'"}], "gold_solution": "def create_seirs_sim(n_agents: int = 5_000, beta: float = 0.2, init_prev: float = 0.1, dur_exp: float = 0.5, dur_inf: float = 5, dur_imm: float = 2.0, p_death: float = 0.0) -> ss.Sim:\n    import starsim as ss\n\n    class SEIR(ss.SIR):\n        def __init__(self, pars=None, *args, **kwargs):\n            super().__init__()\n            self.define_pars(\n                dur_exp=ss.lognorm_ex(0.5),\n            )\n            self.update_pars(pars, **kwargs)\n            self.define_states(\n                ss.BoolState('exposed', label='Exposed'),\n                ss.FloatArr('ti_exposed', label='Time of exposure'),\n            )\n\n        @property\n        def infectious(self):\n            return self.infected | self.exposed\n\n        def step_state(self):\n            super().step_state()\n            infected = self.exposed & (self.ti_infected <= self.ti)\n            self.exposed[infected] = False\n            self.infected[infected] = True\n\n        def step_die(self, uids):\n            super().step_die(uids)\n            self.exposed[uids] = False\n\n        def set_prognoses(self, uids, sources=None):\n            super().set_prognoses(uids, sources)\n            ti = self.ti\n            self.susceptible[uids] = False\n            self.exposed[uids] = True\n            self.ti_exposed[uids] = ti\n            p = self.pars\n            dur_exp = p.dur_exp.rvs(uids)\n            self.ti_infected[uids] = ti + dur_exp\n            dur_inf = p.dur_inf.rvs(uids)\n            will_die = p.p_death.rvs(uids)\n            self.ti_recovered[uids[~will_die]] = ti + dur_inf[~will_die]\n            self.ti_dead[uids[will_die]] = ti + dur_inf[will_die]\n\n    class SEIRS(SEIR):\n        def __init__(self, pars=None, *args, **kwargs):\n            super().__init__()\n            self.define_pars(\n                dur_imm=ss.lognorm_ex(2.0),\n            )\n            self.update_pars(pars, **kwargs)\n            self.define_states(\n                ss.FloatArr('ti_susceptible', label='Time of waning immunity'),\n            )\n\n        def step_state(self):\n            super().step_state()\n            waning = self.recovered & (self.ti_susceptible <= self.ti)\n            self.recovered[waning] = False\n            self.susceptible[waning] = True\n\n        def set_prognoses(self, uids, sources=None):\n            super().set_prognoses(uids, sources)\n            p = self.pars\n            dur_imm = p.dur_imm.rvs(uids)\n            self.ti_susceptible[uids] = self.ti_recovered[uids] + dur_imm\n\n    seirs = SEIRS(beta=beta, init_prev=init_prev, dur_exp=dur_exp, dur_inf=dur_inf, dur_imm=dur_imm, p_death=p_death)\n    sim = ss.Sim(n_agents=n_agents, diseases=seirs, networks='random')\n    sim.run()\n    return sim"}
