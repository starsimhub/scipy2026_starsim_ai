{"problem_id": "starsim_t6", "sub_step_id": "starsim_t6.1", "description": "Compare baseline and vaccinated SIR simulations using Starsim's built-in vaccine product and routine vaccination intervention. Run two 50-year simulations with demographics — one without any intervention (baseline) and one with routine vaccination — and return the cumulative infections from each.", "function_header": "def compare_sir_vaccination(n_agents: int = 5_000, n_contacts: int = 4, beta: float = 0.1, dur_inf: float = 10, vx_efficacy: float = 0.5, vx_prob: float = 0.2, vx_start_year: int = 2015) -> dict[str, float]:", "docstring": "Compare cumulative infections between a baseline SIR simulation and one with routine vaccination.\n\nBoth simulations run from 2000 to 2050 with demographics (birth_rate=20, death_rate=15).\nThe vaccinated simulation uses ss.simple_vx to create a vaccine product and ss.routine_vx\nto deliver it as a routine program.\n\nArgs:\n    n_agents: Number of agents to simulate.\n    n_contacts: Average number of contacts per agent in the random network.\n    beta: Probability of transmission between contacts.\n    dur_inf: Duration of infection in years.\n    vx_efficacy: Efficacy of the vaccine (0 to 1).\n    vx_prob: Probability of vaccination per eligible agent per timestep.\n    vx_start_year: Year to begin routine vaccination.\n\nReturns:\n    Dictionary with keys:\n        - 'baseline_infections': cumulative infections without vaccination\n        - 'vaccinated_infections': cumulative infections with vaccination", "background": "Starsim separates the concept of products (what is administered, e.g., a vaccine) from interventions (how it is delivered, e.g., routine or campaign). ss.simple_vx(efficacy) creates a basic vaccine product, and ss.routine_vx(start_year, prob, product) creates a routine delivery intervention that vaccinates a fraction of eligible agents each timestep. Demographics (births and deaths) are important here because new births create susceptible agents who benefit from ongoing vaccination.", "dependencies": ["starsim"], "test_cases": [{"description": "Result should contain both baseline and vaccinated infection counts", "test": "result = compare_sir_vaccination()\nassert 'baseline_infections' in result, 'Should have baseline_infections'\nassert 'vaccinated_infections' in result, 'Should have vaccinated_infections'"}, {"description": "Both infection counts should be positive", "test": "result = compare_sir_vaccination()\nassert result['baseline_infections'] > 0, 'Baseline should have infections'\nassert result['vaccinated_infections'] > 0, 'Vaccinated scenario should still have some infections'"}, {"description": "Vaccination should reduce cumulative infections compared to baseline", "test": "result = compare_sir_vaccination()\nassert result['vaccinated_infections'] < result['baseline_infections'], 'Vaccination should reduce infections'"}, {"description": "Return values should be floats", "test": "result = compare_sir_vaccination()\nassert isinstance(result['baseline_infections'], float), 'baseline_infections should be a float'\nassert isinstance(result['vaccinated_infections'], float), 'vaccinated_infections should be a float'"}], "gold_solution": "def compare_sir_vaccination(n_agents: int = 5_000, n_contacts: int = 4, beta: float = 0.1, dur_inf: float = 10, vx_efficacy: float = 0.5, vx_prob: float = 0.2, vx_start_year: int = 2015) -> dict[str, float]:\n    import starsim as ss\n    pars = dict(\n        n_agents=n_agents,\n        birth_rate=20,\n        death_rate=15,\n        networks=dict(type='random', n_contacts=n_contacts),\n        diseases=dict(type='sir', dur_inf=dur_inf, beta=beta),\n        start=2000,\n        stop=2050,\n    )\n    sim_base = ss.Sim(pars=pars)\n    sim_base.run()\n    my_vaccine = ss.simple_vx(efficacy=vx_efficacy)\n    my_intv = ss.routine_vx(start_year=vx_start_year, prob=vx_prob, product=my_vaccine)\n    sim_intv = ss.Sim(pars=pars, interventions=my_intv)\n    sim_intv.run()\n    return {\n        'baseline_infections': float(sim_base.results.sir.cum_infections[-1]),\n        'vaccinated_infections': float(sim_intv.results.sir.cum_infections[-1]),\n    }"}
{"problem_id": "starsim_t6", "sub_step_id": "starsim_t6.2", "description": "Create a custom vaccine product for an SIS disease by subclassing ss.Vx. The vaccine should reduce susceptibility (rel_sus) upon administration. Use it with ss.routine_vx to deliver vaccination in an SIS simulation with demographics. Return the completed simulation.", "function_header": "def run_sis_vaccine_sim(n_agents: int = 5_000, n_contacts: int = 4, beta: float = 0.1, dur_inf: float = 10, vx_efficacy: float = 0.9, vx_prob: float = 1.0, vx_start_year: int = 2015) -> ss.Sim:", "docstring": "Run an SIS simulation with a custom vaccine product delivered via routine vaccination.\n\nDefine a custom vaccine class (sis_vaccine) that subclasses ss.Vx. The class should:\n  - Accept an efficacy parameter via define_pars\n  - Override the administer method to reduce rel_sus for vaccinated agents\n    by multiplying rel_sus by (1 - efficacy)\n\nUse this vaccine with ss.routine_vx. The simulation runs from 2000 to 2050\nwith demographics (birth_rate=20, death_rate=15).\n\nArgs:\n    n_agents: Number of agents to simulate.\n    n_contacts: Average number of contacts per agent.\n    beta: Probability of transmission between contacts.\n    dur_inf: Duration of infection in years.\n    vx_efficacy: Efficacy of the custom vaccine (0 to 1).\n    vx_prob: Probability of vaccination per eligible agent per timestep.\n    vx_start_year: Year to begin routine vaccination.\n\nReturns:\n    A Starsim Sim object that has been run to completion.", "background": "Starsim's built-in vaccine products (e.g., ss.simple_vx) work for standard SIR-type diseases, but custom diseases like SIS may require custom vaccine logic. By subclassing ss.Vx and overriding the administer(people, uids) method, you can define exactly how the vaccine affects agents. For an SIS vaccine, reducing rel_sus (relative susceptibility) makes vaccinated agents less likely to become infected. The vaccine product is then paired with a delivery mechanism like ss.routine_vx.", "dependencies": ["starsim"], "test_cases": [{"description": "Simulation should have an SIS disease", "test": "sim = run_sis_vaccine_sim()\nassert hasattr(sim.diseases, 'sis'), 'Simulation should have an SIS disease'"}, {"description": "Simulation should have at least one intervention", "test": "sim = run_sis_vaccine_sim()\nassert len(sim.interventions) > 0, 'Simulation should have at least one intervention'"}, {"description": "Simulation should produce infections", "test": "sim = run_sis_vaccine_sim()\nassert sim.results.sis.cum_infections[-1] > 0, 'There should be at least some infections'"}, {"description": "Population size should match n_agents parameter", "test": "sim = run_sis_vaccine_sim(n_agents=1_000)\nassert sim.pars.n_agents == 1_000, 'Population size should match n_agents'"}], "gold_solution": "def run_sis_vaccine_sim(n_agents: int = 5_000, n_contacts: int = 4, beta: float = 0.1, dur_inf: float = 10, vx_efficacy: float = 0.9, vx_prob: float = 1.0, vx_start_year: int = 2015) -> ss.Sim:\n    import starsim as ss\n\n    class sis_vaccine(ss.Vx):\n        def __init__(self, efficacy=1.0, **kwargs):\n            super().__init__()\n            self.define_pars(efficacy=efficacy)\n            self.update_pars(**kwargs)\n\n        def administer(self, people, uids):\n            people.sis.rel_sus[uids] *= 1 - self.pars.efficacy\n\n    my_vaccine = sis_vaccine(efficacy=vx_efficacy)\n    my_intv = ss.routine_vx(start_year=vx_start_year, prob=vx_prob, product=my_vaccine)\n    pars = dict(\n        n_agents=n_agents,\n        birth_rate=20,\n        death_rate=15,\n        networks=dict(type='random', n_contacts=n_contacts),\n        diseases=dict(type='sis', dur_inf=dur_inf, beta=beta),\n        start=2000,\n        stop=2050,\n    )\n    sim = ss.Sim(pars=pars, interventions=my_intv)\n    sim.run()\n    return sim"}
{"problem_id": "starsim_t6", "sub_step_id": "starsim_t6.3", "description": "Sweep across different vaccine efficacy values to determine the minimum efficacy required to eradicate an SIS disease by 2050. For each efficacy, run a simulation with a custom SIS vaccine at 100% routine coverage and check whether the disease has been eradicated (no new infections in the final timestep). Return results for each efficacy value.", "function_header": "def sweep_sis_vaccine_efficacy(efficacies: list[float], n_agents: int = 5_000, n_contacts: int = 4, beta: float = 0.1, dur_inf: float = 10, vx_start_year: int = 2015) -> dict[float, dict]:", "docstring": "Sweep vaccine efficacy values and check for SIS disease eradication.\n\nFor each efficacy value, define a custom sis_vaccine class (subclassing ss.Vx)\nthat reduces rel_sus, deliver it via ss.routine_vx with 100% coverage, and run\nan SIS simulation from 2000 to 2050 with demographics. Check whether the disease\nis eradicated by examining whether there are zero new infections in the final\ntimestep.\n\nArgs:\n    efficacies: List of vaccine efficacy values to test (0 to 1).\n    n_agents: Number of agents to simulate.\n    n_contacts: Average number of contacts per agent.\n    beta: Probability of transmission between contacts.\n    dur_inf: Duration of infection in years.\n    vx_start_year: Year to begin routine vaccination.\n\nReturns:\n    Dictionary mapping each efficacy value to a dict containing:\n        - 'cum_infections': cumulative infections at end of simulation\n        - 'eradicated': True if new infections in the final timestep is zero", "background": "Finding the minimum vaccine efficacy needed to eliminate a disease is a key question in public health. For an SIS model (where recovered agents become susceptible again), ongoing vaccination must reduce transmission enough that the disease cannot sustain itself. This is related to the concept of the basic reproduction number R0 — the vaccine must reduce the effective reproduction number below 1. By sweeping across efficacy values with 100% coverage, you can identify the approximate threshold. With beta=0.1, n_contacts=4, and dur_inf=10, R0 is approximately 4, so the minimum efficacy threshold is around 0.5.", "dependencies": ["starsim"], "test_cases": [{"description": "Results should contain an entry for each efficacy value", "test": "results = sweep_sis_vaccine_efficacy([0.1, 0.5, 0.9])\nassert set(results.keys()) == {0.1, 0.5, 0.9}, 'Should have results for all efficacy values'"}, {"description": "Each result should contain cum_infections and eradicated", "test": "results = sweep_sis_vaccine_efficacy([0.5])\nassert 'cum_infections' in results[0.5], 'Should contain cum_infections'\nassert 'eradicated' in results[0.5], 'Should contain eradicated'"}, {"description": "High efficacy (0.9) with 100% coverage should eradicate the disease", "test": "results = sweep_sis_vaccine_efficacy([0.9])\nassert results[0.9]['eradicated'] is True, 'Efficacy of 0.9 should eradicate the disease'"}, {"description": "Higher efficacy should result in fewer or equal cumulative infections", "test": "results = sweep_sis_vaccine_efficacy([0.1, 0.9])\nassert results[0.9]['cum_infections'] <= results[0.1]['cum_infections'], 'Higher efficacy should produce fewer infections'"}], "gold_solution": "def sweep_sis_vaccine_efficacy(efficacies: list[float], n_agents: int = 5_000, n_contacts: int = 4, beta: float = 0.1, dur_inf: float = 10, vx_start_year: int = 2015) -> dict[float, dict]:\n    import starsim as ss\n\n    class sis_vaccine(ss.Vx):\n        def __init__(self, efficacy=1.0, **kwargs):\n            super().__init__()\n            self.define_pars(efficacy=efficacy)\n            self.update_pars(**kwargs)\n\n        def administer(self, people, uids):\n            people.sis.rel_sus[uids] *= 1 - self.pars.efficacy\n\n    results = {}\n    for eff in efficacies:\n        my_vaccine = sis_vaccine(efficacy=eff)\n        my_intv = ss.routine_vx(start_year=vx_start_year, prob=1.0, product=my_vaccine)\n        pars = dict(\n            n_agents=n_agents,\n            birth_rate=20,\n            death_rate=15,\n            networks=dict(type='random', n_contacts=n_contacts),\n            diseases=dict(type='sis', dur_inf=dur_inf, beta=beta),\n            start=2000,\n            stop=2050,\n        )\n        sim = ss.Sim(pars=pars, interventions=my_intv)\n        sim.run()\n        results[eff] = {\n            'cum_infections': float(sim.results.sis.cum_infections[-1]),\n            'eradicated': float(sim.results.sis.new_infections[-1]) == 0,\n        }\n    return results"}
